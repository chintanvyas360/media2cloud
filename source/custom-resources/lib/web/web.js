/**
 *  Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.                        *
 *                                                                                                 *
 *  Licensed under the Amazon Software License (the "License"). You may not use this               *
 *  file except in compliance with the License. A copy of the License is located at                *
 *                                                                                                 *
 *      http://aws.amazon.com/asl/                                                                 *
 *                                                                                                 *
 *  or in the "license" file accompanying this file. This file is distributed on an "AS IS"        *
 *  BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express or implied. See the License       *
 *  for the specific language governing permissions and limitations under the License.             *
 *
 */

/**
 * @author MediaEnt Solutions
 */

/* eslint-disable no-console */
/* eslint-disable global-require */
/* eslint-disable no-unused-vars */
/* eslint-disable arrow-body-style */
/* eslint-disable import/no-unresolved */
/* eslint-disable import/no-extraneous-dependencies */
/* eslint no-unused-expressions: ["error", { "allowShortCircuit": true, "allowTernary": true }] */
const URL = require('url');
const HTTPS = require('https');
const ZIP = require('adm-zip');
const MIME = require('mime');
const CRYPTO = require('crypto');
const AWS = require('aws-sdk');

const {
  mxBaseResponse,
} = require('../shared/mxBaseResponse');

/* auto-generated by CloudFormation template */
/* install alongside with the main page location */
const MANIFEST_NAME = 'solution-manifest.js';
const SOLUTIO_MANIFEST_PLACEHOLDER = '<!--SOLUTION_MANIFEST_PLACEHOLDER-->';
const INDEX_HTML = 'demo.html';

class WebContent extends mxBaseResponse(class {}) {
  constructor(event, context) {
    super(event, context);

    const {
      ResourceProperties = {},
    } = event || {};

    /* sanity check */
    const REQUIRED_PROPERTIES = [
      'ServiceToken',
      'FunctionName',
      'SolutionId',
      'SourceBucket',
      'SourceKey',
      'ContentBucket',
    ];

    const missing = REQUIRED_PROPERTIES.filter(x => ResourceProperties[x] === undefined);

    if (missing.length) {
      throw new Error(`event.ResourceProperties missing ${missing.join(', ')}`);
    }

    const {
      SolutionId,
      ContentBucket,
      SourceBucket,
      SourceKey,
    } = ResourceProperties;

    this.$solutionId = SolutionId;
    this.$contentBucket = ContentBucket;
    this.$sourceBucket = SourceBucket;
    this.$sourceKey = SourceKey;
    this.$packageUrl = URL.parse(`https://${this.sourceBucket}-${process.env.AWS_REGION}.s3.amazonaws.com/${this.sourceKey}`);
  }

  get solutionId() {
    return this.$solutionId;
  }

  get sourceBucket() {
    return this.$sourceBucket;
  }

  get sourceKey() {
    return this.$sourceKey;
  }

  get packageUrl() {
    return this.$packageUrl;
  }

  get contentBucket() {
    return this.$contentBucket;
  }

  async downloadHTTP() {
    const promise = new Promise((resolve, reject) => {
      const buffers = [];

      const request = HTTPS.request(this.packageUrl, (response) => {
        response.on('data', chunk =>
          buffers.push(chunk));

        response.on('end', () => {
          if (response.statusCode >= 400) {
            reject(new Error(`${response.statusCode} ${response.statusMessage} ${this.packageUrl.format()}`));
            return;
          }
          resolve(Buffer.concat(buffers));
        });
      });

      request.on('error', e =>
        reject(e));

      request.end();
    });

    return promise;
  }

  async downloadS3() {
    const s3 = new AWS.S3({
      apiVersion: '2006-03-01',
    });

    const response = await s3.getObject({
      Bucket: this.sourceBucket,
      Key: this.sourceKey,
    }).promise();

    return response.Body;
  }

  async downloadPackage() {
    let response;

    try {
      response = await this.downloadS3();

      process.env.ENV_QUIET || console.log(`Downloaded package via s3://${this.sourceBucket}/${this.sourceKey}`);

      return response;
    } catch (e) {
      process.env.ENV_QUIET || console.log(`Failed to download package via s3://${this.sourceBucket}/${this.sourceKey}. Try HTTP GET ${this.packageUrl.format()}`);

      response = await this.downloadHTTP();

      return response;
    }
  }

  async copyFiles(buffer) {
    const unzip = new ZIP(buffer);
    const files = [];
    const Bucket = this.contentBucket;

    const s3 = new AWS.S3({
      apiVersion: '2006-03-01',
    });

    const promises = unzip.getEntries().filter(x => !x.isDirectory).map((entry) => {
      const Body = unzip.readFile(entry.entryName);

      const params = {
        Bucket,
        Key: entry.entryName,
        ContentType: MIME.getType(entry.entryName),
        ServerSideEncryption: 'AES256',
        Body,
      };

      files.push(entry.entryName);

      return s3.putObject(params).promise();
    });

    console.log(`copyFiles = ${JSON.stringify(files, null, 2)}`);

    const responses = await Promise.all(promises);

    if (responses.length !== files.length) {
      throw new Error(`mismatch # of files: ${responses.length}/${files.length}`);
    }

    return files;
  }

  /**
   * @function create
   * @description subscribe a list of emails to SNS topic
   */
  async create() {
    const buffer = await this.downloadPackage();
    const files = await this.copyFiles(buffer);

    this.storeResponseData('Uploaded', files.length);
    this.storeResponseData('Status', 'SUCCESS');

    return this.responseData;
  }

  /**
   * @function purge
   * @description not implememted (not needed)
   */
  async purge() {
    this.storeResponseData('Status', 'SKIPPED');
    return this.responseData;
  }
}


/**
 * @class SolutionManifest
 * @description create solution-manifest.js file and modify demo.html
 */
class SolutionManifest extends mxBaseResponse(class {}) {
  constructor(event, context) {
    super(event, context);
    const {
      ResourceProperties = {},
    } = event || {};

    /* sanity check */
    const REQUIRED_PROPERTIES = [
      'ServiceToken',
      'FunctionName',
      'SolutionId',
      'ContentBucket',
      'CognitoUserPoolId',
      'CognitoAppClientId',
      'CognitoIdentityPoolId',
      'HomePageUrl',
      'ConfigurationTableName',
      'ConfigurationPartitionKey',
      'ConfigurationItemName',
      'Media2CloudEndpoint',
    ];

    const missing = REQUIRED_PROPERTIES.filter(x => ResourceProperties[x] === undefined);

    if (missing.length) {
      throw new Error(`event.ResourceProperties missing ${missing.join(', ')}`);
    }

    const {
      SolutionId,
      ContentBucket,
      CognitoUserPoolId,
      CognitoAppClientId,
      CognitoIdentityPoolId,
      HomePageUrl,
      ConfigurationTableName,
      ConfigurationPartitionKey,
      ConfigurationItemName,
      Media2CloudEndpoint,
    } = ResourceProperties;

    this.$solutionId = SolutionId;
    this.$contentBucket = ContentBucket;
    this.$userPoolId = CognitoUserPoolId;
    this.$appClientId = CognitoAppClientId;
    this.$identityPoolId = CognitoIdentityPoolId;
    this.$homePageUrl = HomePageUrl;
    this.$dbTableName = ConfigurationTableName;
    this.$dbPartitionKey = ConfigurationPartitionKey;
    this.$dbItemName = ConfigurationItemName;
    this.$apiEndpoint = Media2CloudEndpoint;
    this.$packageUrl = URL.parse(`https://${this.sourceBucket}-${process.env.AWS_REGION}.s3.amazonaws.com/${this.sourceKey}`);
  }

  get solutionId() {
    return this.$solutionId;
  }

  get packageUrl() {
    return this.$packageUrl;
  }

  get contentBucket() {
    return this.$contentBucket;
  }

  get userPoolId() {
    return this.$userPoolId;
  }

  get appClientId() {
    return this.$appClientId;
  }

  get identityPoolId() {
    return this.$identityPoolId;
  }

  get homePageUrl() {
    return this.$homePageUrl;
  }

  get dbTableName() {
    return this.$dbTableName;
  }

  get dbPartitionKey() {
    return this.$dbPartitionKey;
  }

  get dbItemName() {
    return this.$dbItemName;
  }

  get apiEndpoint() {
    return this.$apiEndpoint;
  }

  /**
   * @function makeManifest
   * @description generate manifest content. These are the parameters that have to be provided
   * for web app to initially connect to the backend.
   */
  makeManifest() {
    return Buffer.from(`
const ${this.solutionId} = {
  Region: '${process.env.AWS_REGION}',
  Cognito: {
    DomainPrefix: 'xxxx',
    UserPoolId: '${this.userPoolId}',
    ClientId: '${this.appClientId}',
    IdentityPoolId: '${this.identityPoolId}',
    RedirectUri: '${this.homePageUrl}',
  },
  DynamoDB: {
    Configuration: {
      Table: '${this.dbTableName}',
      PartitionKey: '${this.dbPartitionKey}',
      ItemKey: '${this.dbItemName}',
    },
  },
  ApiEndpoint: '${this.apiEndpoint}',
};
    `);
  }

  /**
   * @function copyManifest
   * @description create and install solution-manifest.js
   */
  async copyManifest() {
    const Key = MANIFEST_NAME;

    const manifest = this.makeManifest();
    console.log(manifest.toString());

    const params = {
      Bucket: this.contentBucket,
      Key,
      ContentType: MIME.getType(Key),
      ServerSideEncryption: 'AES256',
      Body: manifest,
    };

    const s3 = new AWS.S3({
      apiVersion: '2006-03-01',
    });

    let response = await s3.putObject(params).promise();

    /* compute manifest file's integrity checksum */
    /* replace <!--SOLUTION_MANIFEST_PLACEHOLDER--> with actual
       <script src="./solution-manifest.js" integrity="integrity"></script> */
    const sha384 = CRYPTO.createHash('sha384');
    const digest = sha384.update(manifest, 'utf-8').digest('hex');
    const integrity = Buffer.from(digest, 'hex').toString('base64');
    const placement = `<script src="./${MANIFEST_NAME}" integrity="sha384-${integrity}"></script>`;

    response = await s3.getObject({ Bucket: this.contentBucket, Key: INDEX_HTML }).promise();

    params.Key = INDEX_HTML;
    params.Body = response.Body.toString().replace(SOLUTIO_MANIFEST_PLACEHOLDER, placement);
    params.ContentType = MIME.getType(params.Key);

    response = await s3.putObject(params).promise();

    return response;
  }

  /**
   * @function create
   * @description subscribe a list of emails to SNS topic
   */
  async create() {
    await this.copyManifest();

    this.storeResponseData('Status', 'SUCCESS');
    return this.responseData;
  }

  /**
   * @function purge
   * @description not implememted (not needed)
   */
  async purge() {
    this.storeResponseData('Status', 'SKIPPED');
    return this.responseData;
  }
}

module.exports = {
  WebContent,
  SolutionManifest,
};
