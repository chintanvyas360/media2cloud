AWSTemplateFormatVersion: "2010-09-09"

Description: (SO0050) Media2Cloud - the solution is designed to demonstrate a serverless ingest framework that can quickly setup a baseline ingest workflow for placing video assets and associated metadata under management control of an AWS customer.

#
# Mappings to store static value of the solution
#
Mappings:
    Solution:
        Project:
            Id: SO0050
        AnonymousUsage:
            Data: "Yes"
        Template:
            S3Bucket: "%BUCKET%"
            KeyPrefix: "%KEYPREFIX%"
        Package:
            CustomResourceX: "%CUSTOMRESOURCES%"
        SNS:
            DisplayName: M2CStatus
        APIGateway:
            StageName: demo
    DynamoDB:
        RecoveryStrategy:
            EnablePITR: true
        PartitionKey:
            Configuration: Item
            Asset: UUID
            Mediainfo: UUID
        ItemName:
            Configuration: configuration
    StepFunctions:
        StateMachine:
            WaitIntervalInSec: 10
    S3:
        CORS:
            AllowedOrigins: "*"
            AllowedMethods: "GET,PUT,POST,HEAD,DELETE"
            AllowedHeaders: "*"
            ExposeHeaders: "Content-Length,ETag,x-amz-meta-uuid,x-amz-meta-umid,x-amz-meta-md5chksum"
            MaxAgeSeconds: "3000"

Parameters:
    CreateBucket:
        Type: String
        Description: "Specify if you want the solution to create an Amazon S3 bucket (with an attached lifecycle policy) to store uploaded videos."
        Default: "Yes"
        AllowedValues:
          - "Yes"
          - "No"
    GlacierBucket:
        Type: String
        Description: "The name of the ingest Amazon S3 bucket. (If you select 'No' for the 'Create Ingest Bucket' parameter, enter your existing bucket name and location)"
        AllowedPattern: "[a-z][a-z0-9-_]*"
    # Media Analysis parameters (Elasticsearch)
    ElasticsearchClusterSize:
        Type: String
        Description: "A drop-down box with three Amazon Elasticsearch cluster sizes: Small, Medium, Large"
        Default: Small
        AllowedValues:
            - Small
            - Medium
            - Large
    # SNS / Cognito parameters
    Email:
        Type: String
        Description: "Email address of the user that will be created in the Amazon Cognito Identity Pool and subscribed to the Amazon SNS topic. Subscribed users will receive ingest, publishing, and error notifications. After launch, two emails will be sent to this address: one with instructions for logging in to the web interface and one confirming the SNS subscription."
        AllowedPattern: '[^\s@]+@[^\s@]+\.[^\s@]+'
    # CloudFront / Website
    PriceClass:
        Type: String
        Description: "Specify the price class of the edge location from which CloudFront serves your requests. For more information, see https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PriceClass.html"
        AllowedValues: [PriceClass_100, PriceClass_200, PriceClass_All]
        Default: PriceClass_100

Metadata:
    AWS::CloudFormation::Interface:
        ParameterGroups:
            -
                Label:
                    default: "Amazon Cognito / SNS Configuration"
                Parameters:
                    - Email
            -
                Label:
                    default: "Amazon S3 / CloudFront Configuration"
                Parameters:
                    - CreateBucket
                    - GlacierBucket
                    - PriceClass
            -
                Label:
                    default: "Media Analysis Configuration"
                Parameters:
                    - ElasticsearchClusterSize

        ParameterLabels:
            CreateBucket:
                default: "Create Ingest Bucket"
            GlacierBucket:
                default: "Ingest Bucket Name"
            ElasticsearchClusterSize:
                default: "Elasticsearch Cluster Size"
            Email:
                default: "Email"
            PriceClass:
                default: "Price Class"

Conditions:
    bEmail: !Not [!Equals [!Ref Email, ""]]
    bUSEast1: !Equals [!Ref "AWS::Region", "us-east-1"]

Resources:
    #
    # allow accesses for custom resource lambda
    #
    CustomResourceExecutionRole:
        Type: AWS::IAM::Role
        Metadata:
            cfn_nag:
                rules_to_suppress:
                    -
                        id: W11
                        reason: "This wildcard is present as the custom resource lambda needs to be able to access contents within the bucket!"
        Properties:
            AssumeRolePolicyDocument:
                Version: "2012-10-17"
                Statement:
                    -
                        Effect: "Allow"
                        Action: ["sts:AssumeRole"]
                        Principal:
                            Service: ["lambda.amazonaws.com"]
            Path: /
            Policies:
                -
                    PolicyName: !Sub ["${x0}-${AWS::StackName}-custom-resources", {x0: !FindInMap ["Solution", "Project", "Id"]}]
                    PolicyDocument:
                        Version: "2012-10-17"
                        Statement:
                        ## S3
                        -
                            Effect: "Allow"
                            Action: [
                                "s3:DeleteObject",
                                "s3:GetAccelerateConfiguration",
                                "s3:GetBucketCORS",
                                "s3:GetBucketNotification",
                                "s3:GetBucketPolicy",
                                "s3:GetBucketTagging",
                                "s3:GetEncryptionConfiguration",
                                "s3:GetLifecycleConfiguration",
                                "s3:GetObject",
                                "s3:GetObjectAcl",
                                "s3:GetObjectTagging",
                                "s3:ListBucket",
                                "s3:PutAccelerateConfiguration",
                                "s3:PutBucketCORS",
                                "s3:PutBucketNotification",
                                "s3:PutBucketPolicy",
                                "s3:PutBucketTagging",
                                "s3:PutEncryptionConfiguration",
                                "s3:PutLifecycleConfiguration",
                                "s3:PutObject",
                                "s3:PutObjectAcl",
                                "s3:PutObjectTagging"
                            ]
                            # This wildcard is present because of circular dependency where
                            # the buckets aren't known before this custom resource lambda function
                            # is created.
                            Resource: [
                                !Sub "arn:aws:s3:::*",
                                !Sub "arn:aws:s3:::*/*"
                            ]

                        ## MediaConvert
                        -
                            Effect: "Allow"
                            Action: [
                                "mediaConvert:DescribeEndpoints",
                            ]
                            # This wildcard is present because the MediaConvert job
                            # IDs are randomly generated.
                            Resource: [
                                !Sub "arn:aws:mediaconvert:${AWS::Region}:${AWS::AccountId}:*"
                            ]

                        ## CloudWatch Logs
                        -
                            Effect: "Allow"
                            Action: [
                                "logs:CreateLogGroup",
                                "logs:CreateLogStream",
                                "logs:PutLogEvents"
                            ]
                            Resource: [
                                !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*"
                            ]

                        ## DynamoDB
                        -
                            Effect: "Allow"
                            Action: [
                                "dynamodb:DeleteItem",
                                "dynamodb:Query",
                                "dynamodb:Scan",
                                "dynamodb:UpdateItem",
                                "dynamodb:Attributes",
                                "dynamodb:LeadingKeys",
                                "dynamodb:ReturnConsumedCapacity",
                                "dynamodb:ReturnValues",
                                "dynamodb:Select"
                            ]
                            Resource: [
                                !Sub [ "arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${x0}-${AWS::StackName}-Configuration", {
                                    x0: !FindInMap ["Solution", "Project", "Id"]
                                }],
                                !Sub [ "arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${x0}-${AWS::StackName}-Asset", {
                                    x0: !FindInMap ["Solution", "Project", "Id"]
                                }],
                                !Sub ["arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${x0}-${AWS::StackName}-Mediainfo", {
                                    x0: !FindInMap ["Solution", "Project", "Id"]
                                }]
                            ]

                        ## IoT
                        -
                            Effect: "Allow"
                            Action: ["iot:Publish"]
                            # The wildcard is needed for the custom resource as Iot resources isn't created at the time
                            Resource: [!Sub "arn:aws:iot:${AWS::Region}:${AWS::AccountId}:topic/*"]
                        -
                            Effect: "Allow"
                            Action: ["iot:ListTargetsForPolicy"]
                            Resource: [!Sub "arn:aws:iot:${AWS::Region}:${AWS::AccountId}:policy/*"]
                        -
                            Effect: "Allow"
                            Action: [
                                "iot:AttachPolicy",
                                "iot:DetachPolicy"
                                ]
                            # This wildcard is present because we are attaching Cognito Identity Id
                            # cert/* and thinggroup/* resources won't work!
                            # resource. See details on https://docs.aws.amazon.com/IAM/latest/UserGuide/list_awsiot.html
                            Resource: !Join ["", ["*"]]
                        -
                            Effect: "Allow"
                            Action: ["iot:DescribeEndpoint"]
                            # This wildcard is present because iot:DescribeEndpoint doesn't take
                            # resource. See details on https://docs.aws.amazon.com/IAM/latest/UserGuide/list_awsiot.html
                            Resource: !Join ["", ["*"]]

                        ## SNS
                        -
                            Effect: "Allow"
                            Action: [
                                "sns:GetSubscriptionAttributes",
                                "sns:GetTopicAttributes",
                                "sns:ListSubscriptionsByTopic",
                                "sns:ListTopics",
                                "sns:SetSubscriptionAttributes",
                                "sns:SetTopicAttributes",
                                "sns:Subscribe",
                                "sns:Unsubscribe"
                            ]
                            # This wildcard is present because the SNS topic is not known
                            # before this custom resource lambda function is created.
                            Resource: [
                                !Sub "arn:aws:sns:${AWS::Region}:${AWS::AccountId}:*"
                            ]

                        ## Lambda
                        -
                            Effect: "Allow"
                            # permission to update lambda environment variables
                            Action: [
                                "lambda:GetFunctionConfiguration",
                                "lambda:UpdateFunctionConfiguration"
                            ]
                            # This wildcard is present as the lambda function yet to be created.
                            Resource: [
                                !Sub "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:*"
                            ]

    #
    # cusotm resource lambda function to help custom actions
    #
    CustomResourceFunction:
        Type: AWS::Lambda::Function
        Properties:
            Description: !Sub ["(${x0}) custom resources", {x0: !FindInMap ["Solution", "Project", "Id"]}]
            Runtime: nodejs8.10
            MemorySize: "128"
            Timeout: "300"
            Handler: index.Run
            Role: !GetAtt CustomResourceExecutionRole.Arn
            Code:
                S3Bucket: !Sub [ "${x0}-${AWS::Region}",{
                    x0: !FindInMap ["Solution", "Template", "S3Bucket"]
                }]
                S3Key: !Sub [ "${x0}/${x1}", {
                    x0: !FindInMap ["Solution", "Template", "KeyPrefix"],
                    x1: !FindInMap ["Solution", "Package", "CustomResourceX"]
                }]

    ################################################################################
    #
    # DynamoDB related resources
    #
    ################################################################################
    #
    # Configuration table stores solution configuration settings
    #
    ConfigurationTable:
        Type: AWS::DynamoDB::Table
        Properties:
            TableName: !Sub [ "${x0}-${AWS::StackName}-Configuration", {
                x0: !FindInMap ["Solution", "Project", "Id"]
            }]
            BillingMode: "PAY_PER_REQUEST"
            AttributeDefinitions:
                -
                    AttributeName: !FindInMap ["DynamoDB", "PartitionKey", "Configuration"]
                    AttributeType: "S"
            KeySchema:
                -
                    AttributeName: !FindInMap ["DynamoDB", "PartitionKey", "Configuration"]
                    KeyType: HASH
            SSESpecification:
                SSEEnabled: true
            PointInTimeRecoverySpecification:
                PointInTimeRecoveryEnabled: !FindInMap ["DynamoDB", "RecoveryStrategy", "EnablePITR"]

    #
    # Asset table stores per-asset information such as glacier, proxy, metadata. This is the main table.
    #
    AssetTable:
        Type: AWS::DynamoDB::Table
        Properties:
            TableName: !Sub [ "${x0}-${AWS::StackName}-Asset", {
                x0: !FindInMap ["Solution", "Project", "Id"]
            }]
            BillingMode: "PAY_PER_REQUEST"
            AttributeDefinitions:
                -
                    AttributeName: !FindInMap ["DynamoDB", "PartitionKey", "Asset"]
                    AttributeType: "S"
            KeySchema:
                -
                    AttributeName: !FindInMap ["DynamoDB", "PartitionKey", "Asset"]
                    KeyType: HASH
            SSESpecification:
                SSEEnabled: true
            PointInTimeRecoverySpecification:
                PointInTimeRecoveryEnabled: !FindInMap ["DynamoDB", "RecoveryStrategy", "EnablePITR"]

    #
    # Mediainfo table stores media info of the asset
    #
    MediainfoTable:
        Type: AWS::DynamoDB::Table
        Properties:
            TableName: !Sub [ "${x0}-${AWS::StackName}-Mediainfo", {
                x0: !FindInMap ["Solution", "Project", "Id"]
            }]
            BillingMode: "PAY_PER_REQUEST"
            AttributeDefinitions:
                -
                    AttributeName: !FindInMap ["DynamoDB", "PartitionKey", "Mediainfo"]
                    AttributeType: "S"
            KeySchema:
                -
                    AttributeName: !FindInMap ["DynamoDB", "PartitionKey", "Mediainfo"]
                    KeyType: HASH
            SSESpecification:
                SSEEnabled: true
            PointInTimeRecoverySpecification:
                PointInTimeRecoveryEnabled: !FindInMap ["DynamoDB", "RecoveryStrategy", "EnablePITR"]

    #
    # call MediaConvert describeEndpoint
    #
    MediaConvertUrl:
        Type: Custom::MediaConvertUrl
        Properties:
            ServiceToken: !GetAtt CustomResourceFunction.Arn
            FunctionName: MediaConvertEndpoint

    #
    # call Iot describeEndpoint
    #
    IotUrl:
        Type: Custom::IotUrl
        Properties:
            ServiceToken: !GetAtt CustomResourceFunction.Arn
            FunctionName: IotEndpoint

    #
    # initialize DyanmoDB table to store configuration
    #
    InitializeDB:
        Type: Custom::InitializeDB
        Properties:
            ServiceToken: !GetAtt CustomResourceFunction.Arn
            FunctionName: InitializeDB
            MediaAnalysisBucket: !GetAtt MediaAnalysisStack.Outputs.MediaAnalysisBucket
            MediaAnalysisApiEndpoint: !GetAtt MediaAnalysisStack.Outputs.MediaAnalysisApiEndpoint
            MediaAnalysisStateMachineName: !GetAtt MediaAnalysisStack.Outputs.MediaAnalysisStateMachineName
            Media2CloudEndpoint: !GetAtt Media2CloudApiGatewayStack.Outputs.Endpoint
            GlacierBucket: !GetAtt GlacierStack.Outputs.BucketName
            MediaConvertRoleArn: !GetAtt StateMachinesStack.Outputs.MediaConvertRoleArn
            SNSTopicArn: !Ref SNSNotificationTopic
            ConfigurationTableName: !Ref ConfigurationTable
            ConfigurationPartitionKey: !FindInMap ["DynamoDB", "PartitionKey", "Configuration"]
            ConfigurationItemName: !FindInMap ["DynamoDB", "ItemName", "Configuration"]
            AssetTableName: !Ref AssetTable
            AssetPartitionKey: !FindInMap ["DynamoDB", "PartitionKey", "Asset"]
            MediainfoTableName: !Ref MediainfoTable
            MediainfoPartitionKey: !FindInMap ["DynamoDB", "PartitionKey", "Mediainfo"]
            IotHost: !GetAtt IotUrl.Endpoint
            IotTopic: !Sub [ "${x0}-${AWS::StackName}/status", {
                x0: !FindInMap ["Solution", "Project", "Id"]
            }]
            IngestStateMachine: !GetAtt StateMachinesStack.Outputs.IngestStateMachineName
            MetadataStateMachine: !GetAtt StateMachinesStack.Outputs.MetadataStateMachineName
            MediaConvertEndpoint: !GetAtt MediaConvertUrl.Endpoint


    ################################################################################
    #
    # S3/Glacier related resources
    #
    ################################################################################
    #
    # Generate a unique name for the media analysis bucket
    #
    RandomizeBucketName:
      Type: Custom::RandomizeBucketName
      Properties:
        ServiceToken: !GetAtt CustomResourceFunction.Arn
        FunctionName: StringManipulation
        InputString: !FindInMap ["Solution", "Project", "Id"]
        Operations: "lower,minlen=3,maxlen=63,dash,random=12"

    #
    # create Glacier bucket stack
    #
    GlacierStack:
        Type: AWS::CloudFormation::Stack
        Properties:
            TemplateURL: !Sub [
                "https://${x0}-${AWS::Region}.s3.amazonaws.com/${x1}/media2cloud-bucket-stack.template",
                { x0: !FindInMap ["Solution", "Template", "S3Bucket"], x1: !FindInMap ["Solution", "Template", "KeyPrefix"] }
            ]
            Parameters:
                S3Bucket: !Sub ["${x0}-${AWS::Region}", { x0: !FindInMap ["Solution", "Template", "S3Bucket"]}]
                KeyPrefix: !FindInMap ["Solution", "Template", "KeyPrefix"]
                SolutionId: !FindInMap ["Solution", "Project", "Id"]
                RootStackName: !Ref "AWS::StackName"
                CreateBucket: !Ref CreateBucket
                GlacierBucket: !Ref GlacierBucket
                CustomResourceArn: !GetAtt CustomResourceFunction.Arn
                IotTopic: !Sub ["${x0}-${AWS::StackName}/status", {x0: !FindInMap ["Solution", "Project", "Id"]}]
                ConfigurationTableName: !Ref ConfigurationTable
                ConfigurationPartitionKey: !FindInMap ["DynamoDB", "PartitionKey", "Configuration"]
                ConfigurationItemName: !FindInMap ["DynamoDB", "ItemName", "Configuration"]
                AssetTableName: !Ref AssetTable
                MediainfoTableName: !Ref MediainfoTable
                SNSTopicArn: !Ref SNSNotificationTopic

    #
    # update glacier bucket CORS
    #
    UpdateGlacierBucketCORS:
        Type: Custom::UpdateGlacierBucketCORS
        Properties:
            ServiceToken: !GetAtt CustomResourceFunction.Arn
            FunctionName: SetCORS
            Bucket: !GetAtt GlacierStack.Outputs.BucketName
            AllowedOrigins: !GetAtt WebAppStack.Outputs.WebsiteUrl
            AllowedMethods: !FindInMap ["S3", "CORS", "AllowedMethods"]
            AllowedHeaders: !FindInMap ["S3", "CORS", "AllowedHeaders"]
            ExposeHeaders: !FindInMap ["S3", "CORS", "ExposeHeaders"]
            MaxAgeSeconds: !FindInMap ["S3", "CORS", "MaxAgeSeconds"]


    ################################################################################
    #
    # Web App related resources
    #
    ################################################################################
    #
    # create Website bucket and Cloudfront distribution stack
    #
    WebAppStack:
        Type: AWS::CloudFormation::Stack
        Properties:
            TemplateURL: !Sub [
                "https://${x0}-${AWS::Region}.s3.amazonaws.com/${x1}/media2cloud-webapp-stack.template",
                { x0: !FindInMap ["Solution", "Template", "S3Bucket"], x1: !FindInMap ["Solution", "Template", "KeyPrefix"] }
            ]
            Parameters:
                S3Bucket: !Sub ["${x0}-${AWS::Region}", { x0: !FindInMap ["Solution", "Template", "S3Bucket"]}]
                KeyPrefix: !FindInMap ["Solution", "Template", "KeyPrefix"]
                SolutionId: !FindInMap ["Solution", "Project", "Id"]
                RootStackName: !Ref "AWS::StackName"
                CustomResourceArn: !GetAtt CustomResourceFunction.Arn
                BucketName: !Sub "${RandomizeBucketName.OutputString}-web"
                PriceClass: !Ref PriceClass

    #
    # Post-processing - update solution-manifest.js in web content bucket
    #
    UpdateManifest:
        Type: Custom::UpdateManifest
        Properties:
            ServiceToken: !GetAtt CustomResourceFunction.Arn
            FunctionName: UpdateManifest
            SolutionId: !FindInMap ["Solution", "Project", "Id"]
            # web zip package to be extracted adn copied to media analysis bucket
            ContentBucket: !GetAtt WebAppStack.Outputs.BucketName
            CognitoUserPoolId: !Ref UserPool
            CognitoAppClientId: !Ref AppClient
            CognitoIdentityPoolId: !Ref IdentityPool
            HomePageUrl: !GetAtt WebAppStack.Outputs.WebsiteUrl
            ConfigurationTableName: !Ref ConfigurationTable
            ConfigurationPartitionKey: !FindInMap ["DynamoDB", "PartitionKey", "Configuration"]
            ConfigurationItemName: !FindInMap ["DynamoDB", "ItemName", "Configuration"]
            Media2CloudEndpoint: !GetAtt Media2CloudApiGatewayStack.Outputs.Endpoint


    ################################################################################
    #
    # Media Analysis related resources
    #
    ################################################################################
    #
    # create media-analysis stack
    #
    MediaAnalysisStack:
        Type: AWS::CloudFormation::Stack
        Properties:
            TemplateURL: !Sub [
                "https://${x0}-${AWS::Region}.s3.amazonaws.com/${x1}/media-analysis-deploy.template",
                { x0: !FindInMap ["Solution", "Template", "S3Bucket"], x1: !FindInMap ["Solution", "Template", "KeyPrefix"] }
            ]
            Parameters:
                S3Bucket: !Sub ["${x0}-${AWS::Region}", { x0: !FindInMap ["Solution", "Template", "S3Bucket"]}]
                KeyPrefix: !FindInMap ["Solution", "Template", "KeyPrefix"]
                SolutionId: !FindInMap ["Solution", "Project", "Id"]
                RootStackName: !Ref "AWS::StackName"
                AnonymousUsage: !FindInMap ["Solution", "AnonymousUsage", "Data"]
                CustomResourceArn: !GetAtt CustomResourceFunction.Arn
                BucketName: !GetAtt RandomizeBucketName.OutputString
                Size: !Ref ElasticsearchClusterSize

    #
    # update media analysis bucket CORS
    #
    UpdateMediaAnalysisBucketCORS:
        Type: Custom::UpdateMediaAnalysisBucketCORS
        Properties:
            ServiceToken: !GetAtt CustomResourceFunction.Arn
            FunctionName: SetCORS
            Bucket: !GetAtt MediaAnalysisStack.Outputs.MediaAnalysisBucket
            AllowedOrigins: !GetAtt WebAppStack.Outputs.WebsiteUrl
            AllowedMethods: !FindInMap ["S3", "CORS", "AllowedMethods"]
            AllowedHeaders: !FindInMap ["S3", "CORS", "AllowedHeaders"]
            ExposeHeaders: !FindInMap ["S3", "CORS", "ExposeHeaders"]
            MaxAgeSeconds: !FindInMap ["S3", "CORS", "MaxAgeSeconds"]


    ################################################################################
    #
    # SNS related resources
    #
    ################################################################################
    #
    # create sns topic / notification
    #
    SNSNotificationTopic:
        Type: AWS::SNS::Topic
        Properties:
            TopicName: !Sub ["${x0}-${AWS::StackName}", {x0: !FindInMap ["Solution", "Project", "Id"]}]
            DisplayName: !FindInMap ["Solution", "SNS", "DisplayName"]

    ## run EmailSubscribe to subscribe emails to SNS topic
    EmailSubscribeFunction:
        Condition: bEmail
        Type: Custom::EmailSubscribe
        Properties:
            ServiceToken: !GetAtt CustomResourceFunction.Arn
            FunctionName: EmailSubscribe
            EmailList: !Ref Email
            TopicArn: !Ref SNSNotificationTopic


    ################################################################################
    #
    # Iot related resources
    #
    ################################################################################
    #
    # Iot Thing resource for MQTT message broker
    #
    IotThing:
        Type: AWS::IoT::Thing
        Properties:
            ThingName: !Sub [ "${x0}-${AWS::StackName}-thing", {
                x0: !FindInMap ["Solution", "Project", "Id"]
            }]

    #
    # allow web app to subscribe, publish, and receice Iot messages
    #
    IotThingPolicy:
        Type: AWS::IoT::Policy
        Properties:
            PolicyName: !Sub [ "${x0}-${AWS::StackName}-thing-policy", {
                x0: !FindInMap ["Solution", "Project", "Id"]
            }]
            PolicyDocument:
                Version: "2012-10-17"
                Statement:
                    -
                        Effect: Allow
                        Action: ["iot:Connect"]
                        ## TODO: Should use Cognito AppClient (or a common secret) to prevent intended connection
                        Resource: [!Sub "arn:aws:iot:${AWS::Region}:${AWS::AccountId}:client/*"]
                    -
                        Effect: Allow
                        Action: ["iot:Subscribe"]
                        Resource: [
                            !Sub [ "arn:aws:iot:${AWS::Region}:${AWS::AccountId}:topicfilter/${x0}-${AWS::StackName}/status", {
                                x0: !FindInMap ["Solution", "Project", "Id"]
                            }]
                        ]
                    -
                        Effect: Allow
                        Action: [
                            "iot:Publish",
                            "iot:Receive"
                        ]
                        Resource: [
                            !Sub [ "arn:aws:iot:${AWS::Region}:${AWS::AccountId}:topic/${x0}-${AWS::StackName}/status", {
                                x0: !FindInMap ["Solution", "Project", "Id"]
                            }]
                        ]

    #
    # on delete stack, we need to clean up Iot policy attached targets.
    # otherwise, stack will fail.
    #
    IotDetachPolices:
        Type: Custom::IotDetachPolices
        Properties:
            ServiceToken: !GetAtt CustomResourceFunction.Arn
            FunctionName: IotDetachPolices
            IotThingPolicy: !Ref IotThingPolicy

    ################################################################################
    #
    # Step Functions/state machine lambda related resources
    #
    ################################################################################
    #
    # create ingest & metadata state machines stack
    #
    StateMachinesStack:
        Type: AWS::CloudFormation::Stack
        Properties:
            TemplateURL: !Sub [
                "https://${x0}-${AWS::Region}.s3.amazonaws.com/${x1}/media2cloud-state-machine-stack.template",
                { x0: !FindInMap ["Solution", "Template", "S3Bucket"], x1: !FindInMap ["Solution", "Template", "KeyPrefix"] }
            ]
            Parameters:
                S3Bucket: !Sub [ "${x0}-${AWS::Region}", {
                    x0: !FindInMap ["Solution", "Template", "S3Bucket"]
                }]
                KeyPrefix: !FindInMap ["Solution", "Template", "KeyPrefix"]
                SolutionId: !FindInMap ["Solution", "Project", "Id"]
                RootStackName: !Ref "AWS::StackName"
                GlacierBucket: !GetAtt GlacierStack.Outputs.BucketName
                SNSTopic: !GetAtt SNSNotificationTopic.TopicName
                MediaAnalysisBucket: !GetAtt MediaAnalysisStack.Outputs.MediaAnalysisBucket
                MediaAnalysisStateMachineName: !GetAtt MediaAnalysisStack.Outputs.MediaAnalysisStateMachineName
                ElasticsearchDomainName: !GetAtt MediaAnalysisStack.Outputs.ElasticsearchDomainName
                WaitIntervalInSec: !FindInMap ["StepFunctions", "StateMachine", "WaitIntervalInSec"]
                IotTopic: !Sub [ "${x0}-${AWS::StackName}/status", {
                    x0: !FindInMap ["Solution", "Project", "Id"]
                }]
                ConfigurationTableName: !Ref ConfigurationTable
                ConfigurationPartitionKey: !FindInMap ["DynamoDB", "PartitionKey", "Configuration"]
                ConfigurationItemName: !FindInMap ["DynamoDB", "ItemName", "Configuration"]
                SNSTopicArn: !Ref SNSNotificationTopic


    ################################################################################
    #
    # API Gateway related resources
    #
    ################################################################################
    #
    # create API Gateway stack for Media2Cloud to start/stop state machine
    #
    Media2CloudApiGatewayStack:
        Type: AWS::CloudFormation::Stack
        Properties:
            TemplateURL: !Sub [
                "https://${x0}-${AWS::Region}.s3.amazonaws.com/${x1}/media2cloud-api-stack.template",
                { x0: !FindInMap ["Solution", "Template", "S3Bucket"], x1: !FindInMap ["Solution", "Template", "KeyPrefix"] }
            ]
            Parameters:
                S3Bucket: !Sub ["${x0}-${AWS::Region}", { x0: !FindInMap ["Solution", "Template", "S3Bucket"]}]
                KeyPrefix: !FindInMap ["Solution", "Template", "KeyPrefix"]
                SolutionId: !FindInMap ["Solution", "Project", "Id"]
                RootStackName: !Ref "AWS::StackName"
                ApiGatewayEndpointName: !Sub ["${x0}-${AWS::StackName}-api", {x0: !FindInMap ["Solution", "Project", "Id"]}]
                StageName: !FindInMap ["Solution", "APIGateway", "StageName"]
                IngestStateMachine: !GetAtt StateMachinesStack.Outputs.IngestStateMachineName
                MetadataStateMachine: !GetAtt StateMachinesStack.Outputs.MetadataStateMachineName
                IotThingPolicy: !Ref IotThingPolicy


    ################################################################################
    #
    # Cognito related resources
    #
    ################################################################################
    #
    # Cognito Identity Pool Name can only contain letters, underscores, space, 128 characters
    #
    SanitizeIdentityPoolName:
        Type: Custom::SanitizeIdentityPoolName
        Properties:
            ServiceToken: !GetAtt CustomResourceFunction.Arn
            FunctionName: StringManipulation
            InputString: !Sub [ "${x0}-${AWS::StackName}-identitypool", {
                x0: !FindInMap ["Solution", "Project", "Id"]
            }]
            Operations: "underscore,maxlen=127"

    #
    # Cognito User pool
    #
    UserPool:
        Type: "AWS::Cognito::UserPool"
        Properties:
            AdminCreateUserConfig:
                AllowAdminCreateUserOnly: true
                InviteMessageTemplate:
                  EmailSubject: "Your Media2Cloud Solution demo login"
                  EmailMessage:
                    !Sub
                        - |-
                            <p>You are invited to join the Media2Cloud Solution demo page. Youre credentials are:</p>
                            <p>
                            Username: <strong>{username}</strong><br />
                            Password: <strong>{####}</strong>
                            </p>
                            <p>
                            Please sign in with the user name and your temporary password provided above at: <br />
                            ${url}
                            </p>
                        - { url: !GetAtt WebAppStack.Outputs.WebsiteUrl }
            AliasAttributes:
                - email
            AutoVerifiedAttributes:
                - email
            MfaConfiguration: 'OFF'
            Policies:
                PasswordPolicy:
                    MinimumLength: 8
                    RequireLowercase: true
                    RequireNumbers: true
                    RequireSymbols: false
                    RequireUppercase: true
            UserPoolName: !Sub [ "${x0}-${AWS::StackName}-userpool", {
                x0: !FindInMap ["Solution", "Project", "Id"]
            }]

    #
    # Cognito App client
    #
    AppClient:
        Type: "AWS::Cognito::UserPoolClient"
        Properties:
            ClientName: !Sub [ "${x0}-${AWS::StackName}-app", {
                x0: !FindInMap ["Solution", "Project", "Id"]
            }]
            RefreshTokenValidity: 30
            UserPoolId: !Ref UserPool

    #
    # Cognito Identity pool
    #
    IdentityPool:
        Type: "AWS::Cognito::IdentityPool"
        Properties:
            IdentityPoolName: !GetAtt SanitizeIdentityPoolName.OutputString
            AllowUnauthenticatedIdentities: false
            CognitoIdentityProviders:
                -
                  ClientId: !Ref AppClient
                  ProviderName: !GetAtt UserPool.ProviderName
                  ServerSideTokenCheck: false

    #
    # Cognito Authenticated user IAM role
    #
    AuthenticatedRole:
        Type: "AWS::IAM::Role"
        Metadata:
            cfn_nag:
                rules_to_suppress:
                    -
                        id: W11
                        reason: "This wildcard is present as the authenticated cognito role needs to be able to access contents within the bucket!"
        Properties:
            AssumeRolePolicyDocument:
                Version: "2012-10-17"
                Statement:
                    -
                        Effect: "Allow"
                        Principal:
                            Federated: "cognito-identity.amazonaws.com"
                        Action: ["sts:AssumeRoleWithWebIdentity"]
                        Condition:
                            StringEquals:
                                cognito-identity.amazonaws.com:aud: !Ref IdentityPool
                            ForAnyValue:StringLike:
                                cognito-identity.amazonaws.com:amr: "authenticated"
            Path: /
            Policies:
                -
                    PolicyName: !Sub [ "${x0}-${AWS::StackName}-CognitoAuthUser", {
                        x0: !FindInMap ["Solution", "Project", "Id"]
                    }]
                    PolicyDocument:
                        Version: "2012-10-17"
                        Statement:
                            ## Cognito
                            -
                                Effect: "Allow"
                                Action: ["cognito-identity:GetId"]
                                Resource: [
                                    !Sub "arn:aws:cognito-identity:${AWS::Region}:${AWS::AccountId}:identitypool/${IdentityPool}"
                                ]
                            ## S3
                            -
                                Effect: "Allow"
                                Action: [
                                    "s3:GetObject",
                                    "s3:PutObject",
                                    "s3:ListBucket"
                                ]
                                Resource: [
                                    !Sub [ "arn:aws:s3:::${x0}", { x0: !GetAtt GlacierStack.Outputs.BucketName }],
                                    !Sub [ "arn:aws:s3:::${x0}/*", { x0: !GetAtt GlacierStack.Outputs.BucketName }],
                                    !Sub [ "arn:aws:s3:::${x0}", { x0: !GetAtt MediaAnalysisStack.Outputs.MediaAnalysisBucket }],
                                    !Sub [ "arn:aws:s3:::${x0}/*", { x0: !GetAtt MediaAnalysisStack.Outputs.MediaAnalysisBucket }]
                                ]
                            -
                                # Allow restore on Glacier bucket only
                                Effect: "Allow"
                                Action: [
                                    "s3:RestoreObject"
                                ]
                                Resource: [
                                    !Sub [ "arn:aws:s3:::${x0}/*", { x0: !GetAtt GlacierStack.Outputs.BucketName }],
                                ]
                            -
                                # Allow delete object on MediaAnalysis/Proxy bucket only
                                Effect: "Allow"
                                Action: [
                                    "s3:DeleteObject"
                                ]
                                Resource: [
                                    !Sub [ "arn:aws:s3:::${x0}/*", { x0: !GetAtt MediaAnalysisStack.Outputs.MediaAnalysisBucket }]
                                ]

                            ## API Gateway
                            -
                                Effect: "Allow"
                                Action: ["execute-api:Invoke"]
                                Resource: [
                                    !Sub [ "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${x0}/prod/GET/*", {
                                        x0: !GetAtt MediaAnalysisStack.Outputs.MediaAnalysisApiId
                                    }],
                                    !Sub [ "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${x0}/*/*/*", {
                                        x0: !GetAtt Media2CloudApiGatewayStack.Outputs.ApiId
                                    }]
                                ]

                            ## DynamoDB
                            -
                                Effect: "Allow"
                                Action: [
                                    "dynamodb:Query",
                                    "dynamodb:Attributes",
                                    "dynamodb:LeadingKeys",
                                    "dynamodb:ReturnConsumedCapacity",
                                    "dynamodb:ReturnValues",
                                    "dynamodb:Select"
                                ]
                                # authenticated user only need read access to Configuration table
                                Resource: [
                                    !Sub "arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${ConfigurationTable}"
                                ]
                            -
                                Effect: "Allow"
                                Action: [
                                    "dynamodb:DeleteItem",
                                    "dynamodb:Query",
                                    "dynamodb:Scan",
                                    "dynamodb:Attributes",
                                    "dynamodb:LeadingKeys",
                                    "dynamodb:ReturnConsumedCapacity",
                                    "dynamodb:ReturnValues",
                                    "dynamodb:Select"
                                ]
                                # authenticated user will have write access to Asset and Mediainfo tables
                                Resource: [
                                    !Sub "arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${AssetTable}",
                                    !Sub "arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${MediainfoTable}"
                                ]

                            ## IoT
                            -
                                Effect: Allow
                                Action: ["iot:Connect"]
                                Resource: [
                                    !Sub "arn:aws:iot:${AWS::Region}:${AWS::AccountId}:client/*"
                                ]
                            -
                                Effect: Allow
                                Action: ["iot:Subscribe"]
                                Resource: [
                                    !Sub [ "arn:aws:iot:${AWS::Region}:${AWS::AccountId}:topicfilter/${x0}-${AWS::StackName}/status", {
                                        x0: !FindInMap ["Solution", "Project", "Id"]
                                    }]
                                ]
                            -
                                Effect: Allow
                                Action: ["iot:Receive"]
                                Resource: [
                                    !Sub [ "arn:aws:iot:${AWS::Region}:${AWS::AccountId}:topic/${x0}-${AWS::StackName}/status", {
                                        x0: !FindInMap ["Solution", "Project", "Id"]
                                    }]
                                ]

    #
    # Cognito attached IAM role to Identity pool
    #
    IdentityPoolRoleAttachment:
        Type: "AWS::Cognito::IdentityPoolRoleAttachment"
        Properties:
            IdentityPoolId: !Ref IdentityPool
            Roles:
                authenticated: !GetAtt AuthenticatedRole.Arn

    #
    # Cognito User pool user based on email address
    #
    UserPoolUser:
        Type: "AWS::Cognito::UserPoolUser"
        Properties:
            DesiredDeliveryMediums:
                - EMAIL
            ForceAliasCreation: false
            UserAttributes:
                -
                  Name: email
                  Value: !Ref Email
            Username: !Select ["0", !Split ["@", !Ref Email]]
            UserPoolId: !Ref UserPool

Outputs:
    ## Custom Resource related
    CustomResourceExecutionRoleArn:
        Value: !GetAtt CustomResourceExecutionRole.Arn
        Description: Role Arn (Custom Resource)
    CustomResourceName:
        Value: !Ref CustomResourceFunction
        Description: Lambda Name (Custom Resource)
    CustomResourceArn:
        Value: !GetAtt CustomResourceFunction.Arn
        Description: Lambda Arn (Custom Resource)

    ## Media Analysis related
    MediaAnalysisBucket:
        Value: !GetAtt MediaAnalysisStack.Outputs.MediaAnalysisBucket
        Description: Bucket (Media Analysis)
    MediaAnalysisApiId:
        Value: !GetAtt MediaAnalysisStack.Outputs.MediaAnalysisApiId
        Description: "API Id (Media Analysis)"
    MediaAnalysisApiEndpoint:
        Value: !GetAtt MediaAnalysisStack.Outputs.MediaAnalysisApiEndpoint
        Description: "API Gateway Endpoint (Media Analysis)"
    SolutionUUID:
        Value: !GetAtt MediaAnalysisStack.Outputs.SolutionUUID
        Description: "Solution UUID (Media Analysis)"
    ElasticsearchDomainName:
        Value: !GetAtt MediaAnalysisStack.Outputs.ElasticsearchDomainName
        Description: "Elasticsearch Domain Name (Media Analysis)"
    ElasticsearchDomainEndpoint:
        Value: !GetAtt MediaAnalysisStack.Outputs.ElasticsearchDomainEndpoint
        Description: "Elasticsearch Domain Endpoint (Media Analysis)"
    MediaAnalysisStateMachineName:
        Value: !GetAtt MediaAnalysisStack.Outputs.MediaAnalysisStateMachineName
        Description: "State Machine Name (Media Analysis)"

    ## SNS related
    SNSTopicName:
        Value: !GetAtt SNSNotificationTopic.TopicName
        Description: Topic Name (SNS)
    SNSTopicArn:
        Value: !Ref SNSNotificationTopic
        Description: Topic Arn (SNS)

    ## DynamoDB related
    ConfigurationTableName:
        Value: !Ref ConfigurationTable
        Description: Table Name (Configuration)
    ConfigurationTableArn:
        Value: !GetAtt ConfigurationTable.Arn
        Description: Table Arn (Configuration)
    ConfigurationPartitionKey:
        Value: !FindInMap ["DynamoDB", "PartitionKey", "Configuration"]
        Description: Partition Key (Configuration)
    ConfigurationItemName:
        Value: !FindInMap ["DynamoDB", "ItemName", "Configuration"]
        Description: Item Key Name (Configuration)
    AssetTableName:
        Value: !Ref AssetTable
        Description: Table Name (Asset)
    AssetTableArn:
        Value: !GetAtt AssetTable.Arn
        Description: Table Arn (Asset)
    AssetPartitionKey:
        Value: !FindInMap ["DynamoDB", "PartitionKey", "Asset"]
        Description: Partition Key (Asset)
    MediainfoTableName:
        Value: !Ref MediainfoTable
        Description: Table Name (Mediainfo)
    MediainfoTableArn:
        Value: !GetAtt MediainfoTable.Arn
        Description: Table Arn (Mediainfo)
    MediainfoPartitionKey:
        Value: !FindInMap ["DynamoDB", "PartitionKey", "Mediainfo"]
        Description: Partition Key (Mediainfo)

    ## Iot related
    IotThingName:
        Value: !Ref IotThing
        Description: Iot Thing Name
    IotThingPolicy:
        Value: !Ref IotThingPolicy
        Description: Iot Thing Policy Name
    IotThingPolicyArn:
        Value: !GetAtt IotThingPolicy.Arn
        Description: Iot Thing Policy Arn
    IotTopic:
        Value: !Sub ["${x0}-${AWS::StackName}/status", {x0: !FindInMap ["Solution", "Project", "Id"]}]
        Description: Iot Message Topic

    ## State machine related
    MediaConvertRoleArn:
        Value: !GetAtt StateMachinesStack.Outputs.MediaConvertRoleArn
        Description: Role Arn (Media2Cloud MediaConvert Service)
    Media2CloudStateMachineExecutionRoleArn:
        Value: !GetAtt StateMachinesStack.Outputs.ExecutionRoleArn
        Description: Role Arn (Media2Cloud State Machine Execution)
    Media2CloudStateMachineServiceRoleArn:
        Value: !GetAtt StateMachinesStack.Outputs.ServiceRoleArn
        Description: Role Arn (Media2Cloud State Machine Service)
    Media2CloudIngestStateMachineArn:
        Value: !GetAtt StateMachinesStack.Outputs.IngestStateMachineArn
        Description: State Machine Arn (Media2Cloud Ingest)
    Media2CloudIngestStateMachineName:
        Value: !GetAtt StateMachinesStack.Outputs.IngestStateMachineName
        Description: State Machine Name (Media2Cloud Ingest)
    Media2CloudMetadataStateMachineArn:
        Value: !GetAtt StateMachinesStack.Outputs.MetadataStateMachineArn
        Description: State Machine Arn (Media2Cloud Metadata)
    Media2CloudMetadataStateMachineName:
        Value: !GetAtt StateMachinesStack.Outputs.MetadataStateMachineName
        Description: State Machine Name (Media2Cloud Metadata)
    Media2CloudStateMachineLambdaList:
        Value: !GetAtt StateMachinesStack.Outputs.LambdaFunctionList
        Description: List of Lambda Functions (Media2Cloud State Machine)

    ## API Gateway related
    Media2CloudApiId:
        Value: !GetAtt Media2CloudApiGatewayStack.Outputs.ApiId
        Description: API Id (Media2Cloud)
    Media2CloudEndpoint:
        Value: !GetAtt Media2CloudApiGatewayStack.Outputs.Endpoint
        Description: API Endpoint (Media2Cloud)

    ## Cognito related
    CognitoUserPoolId:
        Value: !Ref UserPool
        Description: "User Pool ID (Cognito)"
    CognitoUserPoolArn:
        Value: !GetAtt UserPool.Arn
        Description: "User Pool Arn (Cognito)"
    CognitoUserPoolProviderName:
        Value: !GetAtt UserPool.ProviderName
        Description: "User Pool Provider Name (Cognito)"
    CognitoUserPoolProviderURL:
        Value: !GetAtt UserPool.ProviderURL
        Description: "User Pool Provider Url (Cognito)"
    CognitoAppClientId:
        Value: !Ref AppClient
        Description: "App Client ID (Cognito)"
    CognitoIdentityPoolId:
        Value: !Ref IdentityPool
        Description: "Identity Pool (Cognito)"

    ## WebApp related
    WebsiteBucket:
        Value: !GetAtt WebAppStack.Outputs.BucketName
        Description: Bucket (Website)
    DistributionId:
        Value: !GetAtt WebAppStack.Outputs.DistributionId
        Description: Id (CloudFront Distribution)
    HomePageUrl:
        Value: !GetAtt WebAppStack.Outputs.WebsiteUrl
        Description: "Home Page Url (WebApp)"
